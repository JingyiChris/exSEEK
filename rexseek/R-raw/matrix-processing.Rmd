---
title: "matrix processing"
author: "Zhuoer Dong"
date: "November 6, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = F, error = T)
```

https://github.com/lulab/exSeek-dev/blob/master/docs/matrix_processing.md
http://166.111.156.58:8000/jupyter/user/zhuoer/notebooks/exseek/jupyter/matrix_processing.ipynb

# to do:

- use small makrdown to save plot
- check dimension after each step

```{r message=FALSE}
```

# To Do
- 使用哪两类/多类样本
- 路径
- filter写成函数 外界传入要求
- top k 阈值
- 串起来时变量冲突问题
- batch removal需要log再变回去
- cpm，remove pi、mi，top20，reference gene等方法并入R
- RUVs 用或者不用样本信息
- combat必须用类别信息
- alignment score
- ruvs, combat log and reverse
- scnorm分析图
- ruvs分析图
- 确保输入数据格式没有问题

filename, savename, use which operation, pipeline
- Imputation
    - scImpute
- Normalization
    - CPM
    - Top20
    - Remove pi, miRNA
    - TMM
    - RLE
    - SCNorm
- Batch Removal
    - RUVs: need logged normalization matrix
    - Combat: need logged normalization matrix

# load data


```{r read-data}
matrix_path = 'inst/extdata/scirep_sequential_qc.txt'
classinfo_path = 'inst/extdata/scirep_classes.txt'


mat_raw <- matrix_path %>% rexseek::read_mat()
info <- classinfo_path %>% readr::read_csv(T, 'cc') %T>% print
```

```{r filter-low-value}
mat <- mat_raw %>% rexseek::filter_low()
```

```{r to-matrix}
```

```{r make-SingleCellExperiment}
reads <- SingleCellExperiment::SingleCellExperiment(
    assays =  list(counts = mat), colData = info
) %T>% print
```


```{r plotHighestExprs}
reads %>% rexseek::plot_highest_exprs()
```

```{r plotPCA}
reads %>% rexseek::plot_PCA()
```

```{r plotTSNE}
reads %>% rexseek::plot_TSNE()
```


```{r imputation, eval=F}
if(FLASE) {
	impute_tmpdir <- tempdir();
	impute_infile <- paste0(impute_tmpdir, '/pre_counts.csv');
	impute_outdir <- paste0(impute_tmpdir, '/output')
	
	mat %T>% {colnames(.)[1] <- ''} %>% readr::write_csv(impute_infile)
	
	#callr::r(
	do.call(
	    function(...) {scImpute::scimpute(...)}, 
	    args = list(
	        'tmpsave.csv', out_dir = impute_outdir, Kcluster = 5, ncores = 2, labeled = TRUE, 
	        labels = colnames(mat) %>% {.[-1]} %>% plyr::mapvalues(info[[1]], info[[2]], F)
	    )
	)
	
	dir(impute_outdir)
}
```



normalization

```{r norm-pre}
mat %T>% SCnorm::plotCountDepth() %>% colMeans() %>% head
```


```{r norm-SCnorm}
if (!file.exists('data-raw/mat_SCnorm.rds')) {
	mat_SCnorm < mat %>% 
		{SCnorm::SCnorm(., Conditions = rep(1, ncol(.)), PrintProgressPlots = T)} %>% 
		SingleCellExperiment::normcounts()
	readr::write_rds(mat_SCnorm, 'data-raw/mat_SCnorm.rds')
} else
	mat_SCnorm <- readr::read_rds('data-raw/mat_SCnorm.rds')

mat_SCnorm %T>% SCnorm::plotCountDepth() %>% colMeans() %>% head
```


```{r norm-TMM}
mat_tmm <- reads %>% 
	{suppressWarnings(scater::normaliseExprs(., "TMM"))} %>% scater::normalise() %>%
	SingleCellExperiment::normcounts()

mat_tmm %T>% SCnorm::plotCountDepth() %>% colMeans() %>% {./mean(.)} %>% head()
```


```{r norm-RLE}
mat_rle <- reads %>% 
	{suppressWarnings(scater::normaliseExprs(., "RLE"))} %>% scater::normalise() %>%
	SingleCellExperiment::normcounts()

mat_rle %T>% SCnorm::plotCountDepth() %>% colMeans() %>% {./mean(.)} %>% head()
```

```{r norm-CPM}
mat_cpm <- t(t(mat*1e6) / colSums(mat, na.rm = T))

mat_cpm %>% colMeans() %>% head()
```

```{r norm-CPM-top}
k = 20
if (nrow(mat) < k) stop('two few feature for CPM top k normalization')

row_top <- sort(rowMeans(mat), decreasing = T, index.return = T)$ix[seq_len(k)]
mat_cpm_top <- t(t(mat*1e6) / colSums(mat[row_top, ], na.rm = T))

mat_cpm_top %T>% SCnorm::plotCountDepth() %>% colMeans() %>% head()
```

```{r norm-cpm-rm}
annotation <- 'inst/extdata/all.txt' %>% 
	readr::read_file() %>% readr::read_tsv() %>% 
	dplyr::select('transcript_id', 'transcript_type')
mi_pi_id <- annotation %>%
	dplyr::filter(transcript_type %in% c('miRNA', 'piRNA')) %>% .$transcript_id

row_no_mi_pi <- mat %>% rownames() %>% stringr::str_extract('[^|]+') %>% 
	{!(. %in% mi_pi_id)}
mat_cpm_rm <- t(t(mat*1e6) / colSums(mat[row_no_mi_pi, ], na.rm = T))

mat_cpm_rm %T>% SCnorm::plotCountDepth() %>% colMeans() %>% head()
```


# batch effect




```{r}
scIdx <- matrix(-1, ncol = max(table(info$label)), nrow = 2)
tmp <- which(info$label == "Colorectal Cancer")
scIdx[1, 1:length(tmp)] <- tmp
tmp <- which(info$label == "Healthy Control")

#scIdx[2, 1:length(tmp)] <- tmp  #给label信息
scIdx[1, 1:length(tmp)] <- tmp #不给label信息
cIdx <- rownames(mat)
ruvs <- RUVSeq::RUVs(mat, cIdx, k = 10, scIdx = scIdx, isLog = TRUE) #k可调节

```

```{r}
res <- list()
for(n in SummarizedExperiment::assayNames(reads)) {
    res[[n]] <- scRNA.seq.funcs::calc_cell_RLE(SummarizedExperiment::assay(reads, n))
}
par(mar=c(6,4,1,1))
boxplot(res, las=2)
```


```{r}
batch_info <- readr::read_csv('inst/extdata/scirep_batch.txt', T, 'ciii') %>% 
	dplyr::select(sample_id = 1, batch = 2)

combat_data <- log(mat + 0.001)
mod_data <- as.data.frame(t(combat_data))
# Basic batch removal
mod0 = model.matrix(~ 1, mod_data) 
# Preserve biological variability
mod1 = model.matrix(~ info$label, mod_data) 

combat <- sva::ComBat(
    dat = t(mod_data), 
    batch = factor(batch_info$batch), 
    mod = mod1,
    par.prior = TRUE,
    prior.plots = FALSE
)

exp(combat)[1:6, 1:2]


for (n in SummarizedExperiment::assayNames(reads)) {
    print(
        scater::plotQC(
            reads,
            type = "expl",
            exprs_values = n,
            variables = c(
                "total_features",
                "total_counts",
                "Class",
                'RNA.Isolation.batch',
                'library.prepration.day',
                'gel.cut.size.selection'
            )
        ) +
        ggtitle(n)
    )
}

```
